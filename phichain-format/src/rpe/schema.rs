//! Re:PhiEdit json format
//!
//! Credit: https://teamflos.github.io/phira-docs/chart-standard/chart-format/rpe/judgeLine.html

use crate::primitive;
use crate::primitive::PrimitiveChart;
use crate::Format;
use num::{Num, Rational32};
use phichain_chart::beat::Beat;
use phichain_chart::bpm_list::{BpmList, BpmPoint};
use phichain_chart::easing::Easing;
use phichain_chart::event::{LineEvent, LineEventValue};
use phichain_chart::offset::Offset;
use phichain_chart::serialization::{PhichainChart, SerializedLine};
use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};
use tracing::warn;

#[derive(Default, Debug, Clone, PartialEq, Serialize_repr, Deserialize_repr)]
#[repr(u8)]
pub enum RpeNoteKind {
    #[default]
    Tap = 1,
    Drag = 4,
    Hold = 2,
    Flick = 3,
}

// generated by https://transform.tools/json-to-rust-serde
// TODO: event layer, parent support
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RpeBeat(pub i32, pub i32, pub i32);

impl From<RpeBeat> for Beat {
    fn from(val: RpeBeat) -> Self {
        Beat::new(val.0, Rational32::new(val.1, val.2))
    }
}

impl From<Beat> for RpeBeat {
    fn from(value: Beat) -> Self {
        RpeBeat(value.beat(), value.numer(), value.denom())
    }
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RpeChart {
    #[serde(rename = "BPMList")]
    pub bpm_list: Vec<RpeBpmPoint>,
    #[serde(rename = "META")]
    pub meta: RpeMeta,
    pub judge_line_list: Vec<RpeJudgeLine>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RpeBpmPoint {
    pub bpm: f32,
    pub start_time: RpeBeat,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RpeMeta {
    #[serde(rename = "RPEVersion")]
    pub rpe_version: i32,
    pub background: String,
    pub charter: String,
    pub composer: String,
    pub id: String,
    pub level: String,
    pub name: String,
    pub offset: i32,
    pub song: String,
}

fn deserialize_event_layers<'de, D>(deserializer: D) -> Result<Vec<RpeEventLayer>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let layers: Vec<Option<RpeEventLayer>> = Vec::deserialize(deserializer)?;
    Ok(layers.into_iter().flatten().collect())
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RpeJudgeLine {
    /// Before a certain version, the field will be `null` if there's no events in this layer (ref: https://teamflos.github.io/phira-docs/chart-standard/chart-format/rpe/judgeLine.html)
    #[serde(default, deserialize_with = "deserialize_event_layers")]
    pub event_layers: Vec<RpeEventLayer>,
    #[serde(default)]
    pub notes: Vec<RpeNote>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RpeEventLayer {
    #[serde(default)]
    pub alpha_events: Vec<RpeCommonEvent<i32>>,
    #[serde(default, rename = "moveXEvents")]
    pub move_x_events: Vec<RpeCommonEvent<f32>>,
    #[serde(default, rename = "moveYEvents")]
    pub move_y_events: Vec<RpeCommonEvent<f32>>,
    #[serde(default)]
    pub rotate_events: Vec<RpeCommonEvent<f32>>,
    #[serde(default)]
    pub speed_events: Vec<RpeSpeedEvent>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RpeCommonEvent<T: Num> {
    pub bezier: i32,
    #[serde(rename = "bezierPoints")]
    pub bezier_points: [f32; 4],
    pub easing_type: i32,
    pub end: T,
    pub end_time: RpeBeat,
    pub start: T,
    pub start_time: RpeBeat,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RpeSpeedEvent {
    pub end: f32,
    pub end_time: RpeBeat,
    pub start: f32,
    pub start_time: RpeBeat,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RpeNote {
    pub above: i32,
    pub end_time: RpeBeat,
    pub position_x: f32,
    pub speed: f32,
    pub start_time: RpeBeat,
    pub size: f32,         // ignored
    pub visible_time: f32, // ignored
    #[serde(rename = "type")]
    pub kind: RpeNoteKind,
}

pub static RPE_EASING: [Easing; 30] = [
    Easing::Linear,
    Easing::Linear,
    Easing::EaseOutSine,
    Easing::EaseInSine,
    Easing::EaseOutQuad,
    Easing::EaseInQuad,
    Easing::EaseInOutSine,
    Easing::EaseInOutQuad,
    Easing::EaseOutCubic,
    Easing::EaseInCubic,
    Easing::EaseOutQuart,
    Easing::EaseInQuart,
    Easing::EaseInOutCubic,
    Easing::EaseInOutQuart,
    Easing::EaseOutQuint,
    Easing::EaseInQuint,
    Easing::EaseOutExpo,
    Easing::EaseInExpo,
    Easing::EaseOutCirc,
    Easing::EaseInCirc,
    Easing::EaseOutBack,
    Easing::EaseInBack,
    Easing::EaseInOutCirc,
    Easing::EaseInOutBack,
    Easing::EaseOutElastic,
    Easing::EaseInElastic,
    Easing::EaseOutBounce,
    Easing::EaseInBounce,
    Easing::EaseInOutBounce,
    Easing::EaseInOutElastic,
];

pub fn rpe_to_phichain(rpe: RpeChart) -> PhichainChart {
    let mut phichain = PhichainChart {
        offset: Offset(rpe.meta.offset as f32),
        bpm_list: BpmList::new(
            rpe.bpm_list
                .iter()
                .map(|x| BpmPoint::new(x.start_time.clone().into(), x.bpm))
                .collect(),
        ),
        ..Default::default()
    };

    let e = |id: i32| {
        RPE_EASING.get(id as usize).copied().unwrap_or_else(|| {
            warn!("Unknown easing type: {}", id);
            Easing::Linear
        })
    };

    for line in rpe.judge_line_list {
        let x_event_iter = line
            .event_layers
            .iter()
            .flat_map(|layer| layer.move_x_events.clone())
            .map(|event| LineEvent {
                kind: phichain_chart::event::LineEventKind::X,
                start_beat: event.start_time.into(),
                end_beat: event.end_time.into(),
                value: LineEventValue::transition(event.start, event.end, e(event.easing_type)),
            });
        let y_event_iter = line
            .event_layers
            .iter()
            .flat_map(|layer| layer.move_y_events.clone())
            .map(|event| LineEvent {
                kind: phichain_chart::event::LineEventKind::Y,
                start_beat: event.start_time.into(),
                end_beat: event.end_time.into(),
                value: LineEventValue::transition(event.start, event.end, e(event.easing_type)),
            });
        let rotate_event_iter = line
            .event_layers
            .iter()
            .flat_map(|layer| layer.rotate_events.clone())
            .map(|event| LineEvent {
                kind: phichain_chart::event::LineEventKind::Rotation,
                start_beat: event.start_time.into(),
                end_beat: event.end_time.into(),
                // negate value for rotation
                value: LineEventValue::transition(-event.start, -event.end, e(event.easing_type)),
            });
        let alpha_event_iter = line
            .event_layers
            .iter()
            .flat_map(|layer| layer.alpha_events.clone())
            .map(|event| LineEvent {
                kind: phichain_chart::event::LineEventKind::Opacity,
                start_beat: event.start_time.into(),
                end_beat: event.end_time.into(),
                value: LineEventValue::transition(
                    event.start as f32,
                    event.end as f32,
                    e(event.easing_type),
                ),
            });
        let speed_event_iter = line
            .event_layers
            .iter()
            .flat_map(|layer| layer.speed_events.clone())
            .map(|event| LineEvent {
                kind: phichain_chart::event::LineEventKind::Speed,
                start_beat: event.start_time.into(),
                end_beat: event.end_time.into(),
                value: LineEventValue::transition(event.start, event.end, Easing::Linear), // speed events' easing are fixed to be Linear
            });

        phichain.lines.push(SerializedLine {
            notes: line
                .notes
                .iter()
                .map(|note| {
                    let start_beat = Beat::from(note.start_time.clone());
                    let end_beat = Beat::from(note.end_time.clone());
                    let kind: phichain_chart::note::NoteKind = match note.kind {
                        RpeNoteKind::Tap => phichain_chart::note::NoteKind::Tap,
                        RpeNoteKind::Drag => phichain_chart::note::NoteKind::Drag,
                        RpeNoteKind::Hold => phichain_chart::note::NoteKind::Hold {
                            hold_beat: end_beat - start_beat,
                        },
                        RpeNoteKind::Flick => phichain_chart::note::NoteKind::Flick,
                    };

                    phichain_chart::note::Note::new(
                        kind,
                        note.above == 1,
                        start_beat,
                        note.position_x,
                        note.speed,
                    )
                })
                .collect(),
            events: x_event_iter
                .chain(y_event_iter)
                .chain(rotate_event_iter)
                .chain(alpha_event_iter)
                .chain(speed_event_iter)
                .collect(),

            ..Default::default()
        });
    }

    phichain
}

impl Format for RpeChart {
    fn into_primitive(self) -> anyhow::Result<PrimitiveChart> {
        let mut primitive = PrimitiveChart {
            offset: self.meta.offset as f32,
            bpm_list: BpmList::new(
                self.bpm_list
                    .iter()
                    .map(|x| BpmPoint::new(x.start_time.clone().into(), x.bpm))
                    .collect(),
            ),
            lines: vec![],
            ..Default::default()
        };

        let e = |id: i32| {
            RPE_EASING.get(id as usize).copied().unwrap_or_else(|| {
                warn!("Unknown easing type: {}", id);
                Easing::Linear
            })
        };

        for line in self.judge_line_list {
            let x_event_iter = line
                .event_layers
                .iter()
                .flat_map(|layer| layer.move_x_events.clone())
                .map(|event| primitive::event::LineEvent {
                    kind: phichain_chart::event::LineEventKind::X,
                    start_beat: event.start_time.into(),
                    end_beat: event.end_time.into(),
                    start: event.start,
                    end: event.end,
                    easing: e(event.easing_type),
                });
            let y_event_iter = line
                .event_layers
                .iter()
                .flat_map(|layer| layer.move_y_events.clone())
                .map(|event| primitive::event::LineEvent {
                    kind: phichain_chart::event::LineEventKind::Y,
                    start_beat: event.start_time.into(),
                    end_beat: event.end_time.into(),
                    start: event.start,
                    end: event.end,
                    easing: e(event.easing_type),
                });
            let rotate_event_iter = line
                .event_layers
                .iter()
                .flat_map(|layer| layer.rotate_events.clone())
                .map(|event| primitive::event::LineEvent {
                    kind: phichain_chart::event::LineEventKind::Rotation,
                    start_beat: event.start_time.into(),
                    end_beat: event.end_time.into(),
                    // negate value for rotation
                    start: -event.start,
                    end: -event.end,
                    easing: e(event.easing_type),
                });
            let alpha_event_iter = line
                .event_layers
                .iter()
                .flat_map(|layer| layer.alpha_events.clone())
                .map(|event| primitive::event::LineEvent {
                    kind: phichain_chart::event::LineEventKind::Opacity,
                    start_beat: event.start_time.into(),
                    end_beat: event.end_time.into(),
                    start: event.start as f32,
                    end: event.end as f32,
                    easing: e(event.easing_type),
                });
            let speed_event_iter = line
                .event_layers
                .iter()
                .flat_map(|layer| layer.speed_events.clone())
                .map(|event| primitive::event::LineEvent {
                    kind: phichain_chart::event::LineEventKind::Speed,
                    start_beat: event.start_time.into(),
                    end_beat: event.end_time.into(),
                    start: event.start,
                    end: event.end,
                    easing: Easing::Linear, // speed events' easing are fixed to be Linear
                });

            primitive.lines.push(primitive::line::Line {
                notes: line
                    .notes
                    .iter()
                    .map(|note| {
                        let start_beat = Beat::from(note.start_time.clone());
                        let end_beat = Beat::from(note.end_time.clone());
                        let kind: phichain_chart::note::NoteKind = match note.kind {
                            RpeNoteKind::Tap => phichain_chart::note::NoteKind::Tap,
                            RpeNoteKind::Drag => phichain_chart::note::NoteKind::Drag,
                            RpeNoteKind::Hold => phichain_chart::note::NoteKind::Hold {
                                hold_beat: end_beat - start_beat,
                            },
                            RpeNoteKind::Flick => phichain_chart::note::NoteKind::Flick,
                        };

                        phichain_chart::note::Note::new(
                            kind,
                            note.above == 1,
                            start_beat,
                            note.position_x,
                            note.speed,
                        )
                    })
                    .collect(),
                events: x_event_iter
                    .chain(y_event_iter)
                    .chain(rotate_event_iter)
                    .chain(alpha_event_iter)
                    .chain(speed_event_iter)
                    .collect(),
            });
        }

        Ok(primitive)
    }

    fn from_primitive(primitive: PrimitiveChart) -> anyhow::Result<Self>
    where
        Self: Sized,
    {
        let mut rpe = RpeChart {
            bpm_list: primitive
                .bpm_list
                .0
                .iter()
                .map(|x| RpeBpmPoint {
                    bpm: x.bpm,
                    start_time: x.beat.into(),
                })
                .collect(),
            meta: RpeMeta {
                offset: primitive.offset as i32,
                ..Default::default()
            },
            judge_line_list: vec![],
        };

        let e = |easing: Easing| {
            RPE_EASING
                .iter()
                .position(|x| *x == easing)
                .unwrap_or_else(|| {
                    warn!("Unknown easing type: {}", easing);
                    1
                })
        };

        for primitive::line::Line { notes, events } in primitive.lines {
            let mut line = RpeJudgeLine::default();
            for note in notes {
                let kind = match note.kind {
                    phichain_chart::note::NoteKind::Tap => RpeNoteKind::Tap,
                    phichain_chart::note::NoteKind::Drag => RpeNoteKind::Drag,
                    phichain_chart::note::NoteKind::Hold { .. } => RpeNoteKind::Hold,
                    phichain_chart::note::NoteKind::Flick => RpeNoteKind::Flick,
                };
                let end_beat = match note.kind {
                    phichain_chart::note::NoteKind::Hold { hold_beat } => note.beat + hold_beat,
                    _ => note.beat,
                };
                line.notes.push(RpeNote {
                    above: if note.above { 1 } else { 2 },
                    end_time: end_beat.into(),
                    position_x: note.x,
                    speed: note.speed,
                    start_time: note.beat.into(),
                    size: 1.0,
                    visible_time: 999999.0,
                    kind,
                });
            }
            let mut event_layer = RpeEventLayer::default();
            for event in events {
                let mut rpe_event = RpeCommonEvent {
                    bezier: 0,
                    bezier_points: [0.0, 0.0, 0.0, 0.0],
                    easing_type: 0,
                    end: event.end,
                    end_time: event.end_beat.into(),
                    start: event.start,
                    start_time: event.start_beat.into(),
                };

                if let Easing::Custom(a, b, c, d) = event.easing {
                    rpe_event.bezier_points = [a, b, c, d];
                    rpe_event.bezier = 1;
                    rpe_event.easing_type = 1;
                } else {
                    rpe_event.easing_type = e(event.easing) as i32;
                }

                match event.kind {
                    phichain_chart::event::LineEventKind::X => {
                        event_layer.move_x_events.push(rpe_event);
                    }
                    phichain_chart::event::LineEventKind::Y => {
                        event_layer.move_y_events.push(rpe_event);
                    }
                    phichain_chart::event::LineEventKind::Rotation => {
                        // negate value for rotation
                        event_layer.rotate_events.push(RpeCommonEvent {
                            bezier: rpe_event.bezier,
                            bezier_points: rpe_event.bezier_points,
                            easing_type: rpe_event.easing_type,
                            end: -rpe_event.end,
                            end_time: rpe_event.end_time,
                            start: -rpe_event.start,
                            start_time: rpe_event.start_time,
                        });
                    }
                    phichain_chart::event::LineEventKind::Opacity => {
                        event_layer.alpha_events.push(RpeCommonEvent {
                            bezier: rpe_event.bezier,
                            bezier_points: rpe_event.bezier_points,
                            easing_type: rpe_event.easing_type,
                            end: rpe_event.end as i32,
                            end_time: rpe_event.end_time,
                            start: rpe_event.start as i32,
                            start_time: rpe_event.start_time,
                        });
                    }
                    phichain_chart::event::LineEventKind::Speed => {
                        event_layer.speed_events.push(RpeSpeedEvent {
                            start: event.start,
                            end: event.end,
                            end_time: event.end_beat.into(),
                            start_time: event.start_beat.into(),
                        })
                    }
                }
            }
            line.event_layers.push(event_layer);

            rpe.judge_line_list.push(line);
        }

        Ok(rpe)
    }
}
